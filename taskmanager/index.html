<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Task Manager</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            width: 90%;
            max-width: 1200px;
            height: 80%;
            display: flex;
            gap: 20px;
        }
        #terminal {
            flex: 1;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        #task-list {
            flex: 1;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        #output {
            margin-bottom: 20px;
        }
        #input-line {
            display: flex;
            align-items: center;
        }
        #prompt {
            margin-right: 10px;
        }
        #input {
            background: none;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            outline: none;
            flex: 1;
        }
        .task-completed {
            text-decoration: line-through;
            color: #008000;
        }
        .error {
            color: #ff0000;
        }
        #file-input {
            display: none;
        }
        #task-list h2 {
            margin: 0 0 20px 0;
            color: #00ff00;
        }
        .task-item {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="terminal">
            <div id="output"></div>
            <div id="input-line">
                <span id="prompt">$</span>
                <input type="text" id="input" autofocus>
            </div>
        </div>
        <div id="task-list">
            <h2>Tasks</h2>
            <div id="task-output"></div>
        </div>
    </div>
    <input type="file" id="file-input" accept=".txt">

    <script>
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const fileInput = document.getElementById('file-input');
        const taskOutput = document.getElementById('task-output');
        let tasks = [];

        // Load tasks from localStorage on startup
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('terminalTasks');
            if (saved) {
                tasks = JSON.parse(saved);
            }
            updateTaskList();
        }

        // Save tasks to localStorage
        function saveToLocalStorage() {
            localStorage.setItem('terminalTasks', JSON.stringify(tasks));
        }

        function addOutput(text, className = '') {
            const div = document.createElement('div');
            div.textContent = text;
            if (className) div.className = className;
            output.appendChild(div);
            output.scrollTop = output.scrollHeight;
        }

        function updateTaskList() {
            taskOutput.innerHTML = '';
            if (tasks.length === 0) {
                const div = document.createElement('div');
                div.textContent = 'No tasks.';
                taskOutput.appendChild(div);
                return;
            }
            tasks.forEach((task, index) => {
                const div = document.createElement('div');
                div.className = 'task-item';
                const status = task.completed ? '[X]' : '[ ]';
                div.textContent = `${index + 1}. ${status} ${task.text}`;
                if (task.completed) div.className += ' task-completed';
                taskOutput.appendChild(div);
            });
        }

        function displayTasks() {
            if (tasks.length === 0) {
                addOutput('No tasks.');
                return;
            }
            tasks.forEach((task, index) => {
                const status = task.completed ? '[X]' : '[ ]';
                const text = `${index + 1}. ${status} ${task.text}`;
                addOutput(text, task.completed ? 'task-completed' : '');
            });
        }

        // Export tasks as TXT file
        function exportTasks() {
            const lines = tasks.map(task => {
                const status = task.completed ? '[X]' : '[ ]';
                return `${status} ${task.text}`;
            });
            const data = lines.join('\n');
            const blob = new Blob([data], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tasks.txt';
            a.click();
            URL.revokeObjectURL(url);
            addOutput('Tasks exported to tasks.txt');
        }

        // Import tasks from TXT file
        function importTasks(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const lines = e.target.result.split('\n').filter(line => line.trim());
                    const importedTasks = [];
                    for (const line of lines) {
                        const match = line.match(/^\[(X| )\]\s+(.+)$/);
                        if (!match) {
                            throw new Error('Invalid format: Each line must be "[X] task" or "[ ] task"');
                        }
                        const [, status, text] = match;
                        importedTasks.push({
                            text: text.trim(),
                            completed: status === 'X'
                        });
                    }
                    tasks = importedTasks;
                    saveToLocalStorage();
                    updateTaskList();
                    addOutput('Tasks imported successfully');
                    fileInput.value = ''; // Reset file input
                } catch (error) {
                    addOutput(`Error importing tasks: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        function handleCommand(command) {
            const [cmd, ...args] = command.trim().split(' ');
            const argText = args.join(' ');

            switch (cmd.toLowerCase()) {
                case 'add':
                    if (!argText) {
                        addOutput('Error: Task description required.', 'error');
                        return;
                    }
                    tasks.push({ text: argText, completed: false });
                    saveToLocalStorage();
                    updateTaskList();
                    addOutput(`Task added: ${argText}`);
                    break;

                case 'list':
                    displayTasks();
                    break;

                case 'complete':
                    const index = parseInt(argText) - 1;
                    if (isNaN(index) || index < 0 || index >= tasks.length) {
                        addOutput('Error: Invalid task number.', 'error');
                        return;
                    }
                    tasks[index].completed = true;
                    saveToLocalStorage();
                    updateTaskList();
                    addOutput(`Task ${index + 1} marked as completed.`);
                    break;

                case 'delete':
                    if (argText.toLowerCase() === 'all') {
                        if (tasks.length === 0) {
                            addOutput('No tasks to delete.');
                            return;
                        }
                        tasks = [];
                        saveToLocalStorage();
                        updateTaskList();
                        addOutput('All tasks deleted.');
                        return;
                    }
                    const delIndex = parseInt(argText) - 1;
                    if (isNaN(delIndex) || delIndex < 0 || delIndex >= tasks.length) {
                        addOutput('Error: Invalid task number.', 'error');
                        return;
                    }
                    const deleted = tasks.splice(delIndex, 1)[0];
                    saveToLocalStorage();
                    updateTaskList();
                    addOutput(`Task deleted: ${deleted.text}`);
                    break;

                case 'clear':
                    output.innerHTML = '';
                    break;

                case 'export':
                    exportTasks();
                    break;

                case 'import':
                    fileInput.click();
                    break;

                case 'help':
                    addOutput('Commands:');
                    addOutput('  add <task>    - Add a new task');
                    addOutput('  list          - List all tasks');
                    addOutput('  complete <n>  - Mark task n as completed');
                    addOutput('  delete <n>    - Delete task n');
                    addOutput('  delete all    - Delete all tasks');
                    addOutput('  export        - Export tasks to TXT file');
                    addOutput('  import        - Import tasks from TXT file');
                    addOutput('  clear         - Clear terminal');
                    addOutput('  help          - Show this help');
                    break;

                default:
                    if (command) {
                        addOutput(`Unknown command: ${command}. Type 'help' for commands.`, 'error');
                    }
            }
        }

        // Initialize
        loadFromLocalStorage();
        addOutput('Welcome to Terminal Task Manager. Type "help" for commands.');

        // Event listeners
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const command = input.value;
                addOutput(`$ ${command}`);
                handleCommand(command);
                input.value = '';
            }
        });

        fileInput.addEventListener('change', importTasks);
    </script>
</body>
</html>